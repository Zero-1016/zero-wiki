# 트리

## 트리 개념

트리는 데이터를 저장하고 탐색하기에 유용한 구조입니다.

#### 트리의 특성을 활용하는 분야

- 인공지능: 인공지능의 판단 기준을 만들 때 의사 결정 트리를 사용합니다.
- 자동 완성 기능: 트리는 문자열 처리에도 많이 활용됩니다. 예를 들어 검색 엔진에서 자동 검색어 추천 기능도 트라이라는 독특한 트리 구조를 활용한 것입니다.
- 데이터베이스: 데이터를 쉽게 검색, 삽입, 삭제를 할 수 있도록 트리를 활용해서 데이터를 구조화하고 인덱싱합니다.

### 나무를 거꾸로 뒤집어 놓은 모양의 트리

트리는 나무 기둥에서 가지가 뻗어나가는 모습을 거꾸로 뒤집어 놓은 모양입니다. 따라서 나무의 뿌리(root)는 맨 위에 있습니다.

<img src="트리.png" alt="트리 자료구조"/>

### 트리를 구성하는 요소들

#### 트리를 구성하는 노드

<img src="트리 설명.png" alt="트리 한글 설명"/>

노드는 트리를 구성하는 요소입니다. 노드 중 가장 위에 있는 노드를 **루트 노드**라고 합니다. 앞에 그림에서는 A가 루트 노드입니다.

#### 노드를 연결하는 간선

노드와 노드 사이를 연결해주는 선을 우리는 **간선** 또는 **에지(Edge)** 라고 합니다. 이러한 간선들은 상위 노드에서 하위 노드로 단방향으로 연결이 되어있으며, 루트 노드에서의 간선은 하나로 유일합니다.

> 루트 노드로부터 특정 노드까지 거쳐가는 최소한의 간선 수를 레벨로 표현합니다.

#### 부모-자식, 형제 관계를 가지는 노드

간선으로 연결된 노드들은 서로 **부모-자식 관계**가 있다고 합니다. 위에 있는 노드를 **부모 노드** 아래에 있는 노드를 **자식 노드**라고 합니다. F와 G처럼 같은 부모노드를 갖는 노드를 우리는 **형제 노드**라고
부릅니다.

#### 자식이 없는 말단 노드

자식이 없는 노드는 **리프 노드(Leaf Node)** 라고 부릅니다.

#### 아래로 향하는 간선의 개수, 차수

**차수(degree)** 란 특정 노드에서 아래로 향하는 간선의 개수입니다. 예를 들어 노드 B는 차수가 2입니다. 아래로 향하는 간선의 개수가 2개이기 때문입니다.

> 트리 종류는 다양하지만 코딩 테스트에서는 **이진 트리**만 제대로 알고 있으면 충분합니다. 이진 트리는 최대 차수가 2를 넘지 않는 트리를 말합니다.

## 이진 트리 표현하기

이진 트리는 배열이나 포인터로 표현할 수 있습니다.

### 배열로 표현하기

배열로 트리를 표현하려면 다음 3가지 규칙이 필요합니다.

1. 루트 노드는 배열 인덱스 1번에 저장합니다.
2. 왼쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 X 2 입니다.**
3. 오른쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 X 2 + 1 입니다.**

<img src="배열 트리.png" alt="배열 트리"/>

> 인덱스를 0이 아닌 1로 시작하는 이유는 인덱스 계산식이 달라지기 때문입니다. 인덱스를 0으로 해도 괜찮습니다.

트리로 배열을 만들게 될 경우 아주 쉽게 구현할 수 있습니다. 하지만 메모리 낭비가 심할 수 있습니다. 메모리만 넉넉하다면 구현 시간을 단축하는 용도로 사용해도 좋습니다.

### 이진 트리 순회하기

이진 트리를 순회하는 방법은 총 3가지로 전위 순회, 중위 순회, 후위 순회가 있습니다.

- 전위 순회: **현재 노드를 부모 노드로 생각했을 때** 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드 순서로 방문합니다.
- 중위 순회: **현재 노드를 부모 노드로 생각했을 때** 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드 순서로 방문합니다.
- 후위 순회: **현재 노드를 부모 노드로 생각했을 때** 오른쪽 자식 노드 -> 부모 노드 -> 왼쪽 자식 노드 순서로 방문합니다.

> 순위에서 주목해야 할 표현은 '현재 노드를 부모 노드로 생각했을 때'입니다. 이 콘셉트를 이해해야 순회를 쉽게 이해할 수 있습니다.

## 이진 트리 탐색 하기

이진 트리에서 가장 중요한 것은 **탐색을 효율적으로 할 수 있도록 트리를 구축하는 것**입니다.

### 이진 탐색 트리 구축하기

이진 탐색 트리의 대상 데이터가 3 -> 4 -> 2 -> 1 -> 9 -> 5 순서로 들어온다고 생각하고 이진 탐색 트리를 구축한다고 할 때, 이진 탐색 트리는 **데이터의 크기를 따져 현재 노드보다 값이 작으면
왼쪽 자식 위치에, 크거나 같으면 오른쪽 자식 위치에 배치하는 독특한 정렬 방식을 갖고 있습니다.**

### 이진 탐색 트리 탐색하기

구축하기에서 정렬을 하여 집어넣었기 때문에 찾을 때는 쉽게 찾을 수 있습니다.

1. 찾으려는 값이 현재 노드의 값과 같으면 탐색을 종료하고 찾고자 하는 값이 더 크다면 오른쪽 노드를 탐색합니다.
2. 본인이 찾으려는 값이 현재 노드의 값보다 작으면 왼쪽 노드를 탐색합니다.
3. 값을 찾으면 종료합니다. 노드가 없을 때까지 탐색을 했다면 현재 트리에 값이 없는 것입니다.

#### 배열 탐색과 비교한다면 어떨까?

배열로 구현을 했을 때는 하나하나 전부 탐색을 하여야 했습니다. 하지만 이진 탐색 트리는 단 2번만 비교 연산을 진행하여 알아냈습니다.

#### 이진 탐색 트리의 시간 복잡도

이진 탐색 트리는 모든 트리를 탐색하는 것이 아닙니다. 만약 찾는 값이 현재 값보다 크다면 오른쪽을, 작다면 왼쪽을 탐색합니다 때문에 걸리는 시간 복잡도는 $O(logN)$의 시간이 걸리게 됩니다.

### 이진 탐색 트리와 배열 탐색의 효율 비교

위에서 본 것처럼 이진 탐색 트리에서 탐색하는 것이 배열로 탐색하는 것보다 효율이 좋을 것 같다고 할 수 있습니다. 하지만 두 자료구조의 삽입과 탐색 시간 복잡도는 이진 탐색 트리의 균형이 맞지 않으면, 최악의 경우
$O(N)$으로 같다고 얘기합니다.

#### 치우쳐진 형태의 트리

<img src="degenerate binary tree.png" alt="치우쳐진 트리"/>

위에 보이는 트리처럼 만약 91이라는 값을 찾는다면 해당 트리의 시간 복잡도는 $O(N)$이 되고 맙니다. 하지만 이런 경우는 매우 극단적인 상황입니다.

#### 균형 이진 탐색 트리

위처럼 치우치지 않도록 하는 이진 탐색 트리를 균형 이진 탐색 트리라고 합니다. 이런 트리는 세부적으로 AVL 트리, 레드-블랙 트리 등으로 구분하여 부릅니다. 또한 트리의 높이는 logN이므로 시간 복잡도를 $O(
logN)$으로 유지할 수 있습니다. 다만 구현 난이도가 높아 코딩 테스트에는 나오지 않을 가능성이 높습니다.